Laws
============
2017-01-31




About widget targeting
===========================


Layout (-> widgetGroup)* -> widget


1. Requirement: Controller can target any widget


2. Implementation: give each widget a unique name, and each widget group a unique name.


The layout basically holds a tree of widget/widget groups.
Each node of the tree has a unique name.
A leaf is necessarily a widget.
The path of the widget is used as its configuration id. 



About layout tree creation
=============================

1. Wish: the layout tree is consistent; it can be updated either from the bo, or the code, it doesn't matter


2. Implementation:

A layout has a number of widget groups bound to it.
Those bindures are hardcoded (cannot update them via bo).

The ensemble layout/widget groups is called the **layout skeleton**.

Widgets can be bound to the layout skeleton, either from the bo or from the code.



The layout has an init method.
The init method of the layout is responsible for creating the layout tree.
It calls the following two methods in the layout:

- prepareWidgetGroups
- prepareWidgets


The prepareWidgetGroups method is used to create the layout skeleton, it is hardcoded.
The prepareWidgets method is used to bind widgets to the layout skeleton.

It's hardcoded too, to allow a regular developer to bind widgets via the code.
But the prepareWidgets method has been purposely isolated to ease external update (via the bo).

Note: the intent is that the bo updates the code directly, so that the developer
feels comfortable with the code.
In other words, and in general in zuk, the bo is just considered as a helper for the developer.



Theming
==============

Laws system wouldn't be complete without theming.
Theming is the ability to change the theme of a web application with ease.

Basically, all the files related to the theme are located in one directory, so that 
you can change the theme just by copying the directory and modifying the templates inside of it.

In laws, we distinguish between layout files and template files.

Layout files represent either the Layout object or widget groups, while template files
are only used by widgets.
 
A layout file can contain references to:

- widget groups 
- widgets
- layout variables


A template file can contain references to:

- widget variables


In theme files we will need loops and conditions.
Therefore php is allowed.

One of the objective of my theming implementation is that all files can be stored in 
the following structure:

```txt
- app/
----- theme/ 
---------- mytheme/ 
-------------- layouts/ 
------------------ ...all the layouts  
-------------- templates/ 
------------------ ...all the templates  
```

We have to keep in mind that those layouts and templates might come from modules.
This means the theme files can have multiple locations.

Hence I want to provide a loader object, that basically takes a node path and 
returns a concrete filesystem file, thus allowing the desired override mechanism.

Node path is useful when the theme files are located in a "shared" directory (as opposed to a module "owner" directory).

The structure becomes something like that:



todo: why controller name, where does it come from
```txt
- app/
----- theme/ 
---------- mytheme/ 
-------------- layouts/ 
------------------ ControllerName/  
---------------------- myLayout/  
-------------------------- widgetGroupOne/  
------------------------------ widgetOne???
-------------- templates/ 
------------------ ...all the templates  
```
 





New
==========

So, the basically the tree contains three types of elements:

- layout
- widget groups
- widgets

The layout is the topmost element, then we have any number of widget groups, including zero,
and at the end we have the widgets, which display the main components of the page.

Each element is displayed through a file associated with it.
The layout has a layout file.
The widget group has a widget group file.
The widget has a widget file, also called template.

The layout file contains the layout of the page: an html canvas calling the necessary widget groups and/or widgets,
and possibly some layout variables.

The widget group file works the same: it can render either widget groups and/or widgets, although its primary
function is just to contain an array of widgets.

Then the widget file can display widget variables only (variables created inside the widget).


Our goal is to be able to decide WHERE exactly we want those theme files.

Actually, in a zuk application, our goal is to be able to switch themes easily.
The layout objects and widget objects will originate from modules.

Here is the structure I envision (notice that all theme files end with .tpl):

```txt
- app/
----- class-modules/
--------- MyModule/
------------- themes/   
----------------- default/    # default is a special identifier that identifies the default theme that each module should have
--------------------- layouts/ 
------------------------- MyModuleFirstLayout.tpl 
------------------------- ...
--------------------- widgetgroups/ 
------------------------- MyModuleFirstLayout/ 
----------------------------- widgetGroupName.tpl
----------------------------- widgetGroupName2/
--------------------------------- nestedWidgetGroupName.tpl
----------------------------- widgetGroupName3.tpl
------------------------- ... 
--------------------- widgets/
------------------------- MyModuleFirstLayout/ 
----------------------------- widgetGroupName/
--------------------------------- widgetOne.tpl
--------------------------------- ...
------------------------- ... 
--------- MyModule2/
--------- ...
```


But then, the maintainer of the application should be able to override the theme, so here is how I envisioned
a theme override:


```txt
- app/
----- class-modules/
----- themes/
--------- mytheme/
------------- MyModule/
----------------- themes/   
--------------------- default/    # default is a special identifier that identifies the default theme that each module should have
------------------------- layouts/ 
----------------------------- MyModuleFirstLayout.tpl 
----------------------------- ...
------------------------- widgetgroups/ 
----------------------------- MyModuleFirstLayout/ 
--------------------------------- widgetGroupName.tpl
--------------------------------- widgetGroupName2/
------------------------------------- nestedWidgetGroupName.tpl
--------------------------------- widgetGroupName3.tpl
----------------------------- ... 
------------------------- widgets/
----------------------------- MyModuleFirstLayout/ 
--------------------------------- widgetGroupName/
------------------------------------- widgetOne.tpl
------------------------------------- ...
----------------------------- ... 
------------- MyModule2/
------------- ...
```

As you can see, every theme file is located in the **app/themes/mytheme/** directory.
So now we have it: if we want to create a new theme, we just need to copy the **app/themes/mytheme/** directory
and rename it **app/themes/mysecondtheme/** for instance.
 
So, implementation wise, in order to create such a system, I give every element a name (i.e. layouts,
widget groups, widgets all have a name).

By doing so, we can target every node by concatening the names, this is called the **node path**.
 





 
 
 



 
 
 
 
 
 
 











